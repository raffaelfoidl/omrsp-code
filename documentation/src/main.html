<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import csv
import math
import os

from awarded_movie import AwardedMovie
from movie import Movie
from oscar_info import OscarInfo

import numpy as np
import matplotlib.ticker as ticker
import matplotlib.pyplot as plt

from pathlib import Path
from typing import Iterable, List, Collection, Type, TypeVar, Callable

source_root, _ = os.path.split(__file__)
data_folder = os.path.abspath(os.path.join(source_root, &#34;..&#34;, &#34;data&#34;))
result_folder = os.path.abspath(os.path.join(source_root, &#34;..&#34;, &#34;result&#34;))

movie_data_file = os.path.join(data_folder, &#34;movies.csv&#34;)
oscars_data_file = os.path.join(data_folder, &#34;the_oscar_award.csv&#34;)
awarded_movies_result_file = os.path.join(result_folder, &#34;awarded_movies.csv&#34;)
awarded_movies_visualization_file = os.path.join(result_folder, &#34;awarded_movies_visualization.png&#34;)

_T = TypeVar(&#39;_T&#39;)


def read_csv(file_path: str, expected_headers: Iterable[str], target_type: Type[_T], predicate: Callable[[_T], bool],
             encoding=&#34;utf-8&#34;, delimiter=&#34;,&#34;) -&gt; Collection[_T]:
    &#34;&#34;&#34;
    Generic function to deserialize a CSV file into a collection of instances of a specifiable model class. The model class
    has to provide a constructor that accepts string parameters representing the columns of a row in the CSV file, in the order defined by the file.

    **file_path:** the file path to the CSV file to be read&lt;br/&gt;
    **expected_headers:** The headers the CSV file is expected to exhibit. If diverging headers are encountered,
     an exception with information about the headers that were found in the file is thrown.&lt;br/&gt;
    **target_type:** The type (i. e. class) into which CSV entries are deserialized. The class is expected to provide a constructor
     that takes the columns&#39; values as string arguments and constructs an instance from them. If such a constructor is not available, a
     runtime error will ensue. If the constructor invocation itself fails - e. g. due to a string -&gt; int parsing error - a warning is
     printed to stdout and the corresponding row is skipped, i. e. execution continues normally.&lt;br/&gt;
    **predicate:** A row entry read from the CSV is added to the return value only if the predicate, invoked with the deserialized
     model instance as argument, evaluates to true.&lt;br/&gt;
    **encoding:** The encoding to be used when reading the file.&lt;br/&gt;
    **delimiter:** a one-character string to be used as the column separator&lt;br/&gt;

    **returns:** Returns a collection of instances of the generic type parameter that were successfully deserialized from the specified
     CSV file and also satisfied the given predicate.&lt;br/&gt;

    **return type:** `Collection[_T]`
    &#34;&#34;&#34;
    try:
        with open(file_path, encoding=encoding) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=delimiter)
            return_value: List[_T] = []

            headers = next(csv_reader)
            if headers != expected_headers:
                raise Exception(f&#34;Unexpected CSV headers. Check if &#39;{file_path}&#39; is the correct file.\n&#34;
                                f&#34;Expected: {expected_headers}\nActual:   {headers}&#34;)

            for row in csv_reader:
                try:
                    # as per the precondition formulated in the documentation, the model classes provide constructors that
                    # take the string value of each column as parameters and try to parse them into the correct data types
                    new_entry: _T = target_type(*row)
                except Exception as ex:
                    print(f&#34;Skipping entry {row} because it cannot be deserialized.\n  Error: {ex}&#34;)

                if predicate(new_entry):
                    return_value.append(new_entry)

            return return_value
    except FileNotFoundError as ex:
        print(f&#34;Could not read CSV file at \&#34;{file_path}\&#34;.\n  Error: {ex}&#34;)
        print(f&#34;Aborting because the experiment cannot be conducted if at least one data set cannot be read.&#34;)
        exit(1)


def read_oscar_data() -&gt; Collection[OscarInfo]:
    &#34;&#34;&#34;
    Parses the CSV dataset with Oscar nomination and winners from 1928 until 2020, applies a filter by year and category and deserializes the
    entries satisfying the criteria into `OscarInfo` model instances.

    **returns:** Returns a collection of `OscarInfo` instances that represents information from the Oscar award dataset describing Oscar winners
     released 1986 and 2016 (both inclusively) from the category &#34;Best Picture&#34;.&lt;br/&gt;

    **return type:** `Collection[OscarInfo]`
    &#34;&#34;&#34;

    def is_relevant(oscar_info: OscarInfo) -&gt; bool:
        # we are only interested in oscar infos that represent the winners of a &#34;Best Picture&#34; award released between 1986 and 2016 (both inclusively)
        return (1986 &lt;= oscar_info.year_film &lt;= 2016) and (oscar_info.category.lower() == &#34;best picture&#34;) and (oscar_info.winner is True)

    expected_headers = [&#34;year_film&#34;, &#34;year_ceremony&#34;, &#34;ceremony&#34;, &#34;category&#34;, &#34;name&#34;, &#34;film&#34;, &#34;winner&#34;]

    return read_csv(oscars_data_file, expected_headers, OscarInfo, is_relevant)


def read_movie_data() -&gt; Collection[Movie]:
    &#34;&#34;&#34;
    Parses the CSV dataset with IMDb information about movies from 1986 to 2016 and deserializes it into `Movie` model instances.

    **returns:** Returns a collection of `Movie` instances that represents the raw information of the IMDb movie dataset.&lt;br/&gt;

    **return type:** `Collection[Movie]`
    &#34;&#34;&#34;

    def is_relevant(_: Movie) -&gt; bool:
        # all movie entries are relevant
        return True

    expected_headers = [&#34;budget&#34;, &#34;company&#34;, &#34;country&#34;, &#34;director&#34;, &#34;genre&#34;, &#34;gross&#34;, &#34;name&#34;, &#34;rating&#34;,
                        &#34;released&#34;, &#34;runtime&#34;, &#34;score&#34;, &#34;star&#34;, &#34;votes&#34;, &#34;writer&#34;, &#34;year&#34;]

    return read_csv(movie_data_file, expected_headers, Movie, is_relevant)


def match_awarded_movies(oscar_infos: Iterable[OscarInfo], movies: Iterable[Movie]) -&gt; Collection[AwardedMovie]:
    &#34;&#34;&#34;
    Matches the information gathered from the Oscar dataset with the one gathered from the IMDb movie dataset. Two entries are
    defined to be &#34;matching&#34; if the title and year of the film described are equal in both datasets - i. e. film identity is
    defined by the name and finalization/release year.

    **oscar_infos:** relevant oscar award information to be taken into consideration for the matching&lt;br/&gt;
    **movies:** movie data with IMDb information (gross revenue, user score) to be matched with the oscar infos&lt;br/&gt;

    **returns:** Returns a collection of `AwardedMovie` model instances that represents the processed data gathered by means of the matching.&lt;br/&gt;

    **return type:** `Collection[AwardedMovie]`
    &#34;&#34;&#34;
    awarded_movies: List[AwardedMovie] = []

    for oscar_info in oscar_infos:
        def is_match(movie: Movie):
            # we consider a movie equal if the name and year are equal
            return (oscar_info.film.lower() == movie.name.lower()) and (oscar_info.year_film in [movie.year, movie.released.year])

        matched_movie: Movie = next(filter(is_match, movies), None)
        if matched_movie is not None:
            awarded_movies.append(AwardedMovie(oscar_info.year_film, oscar_info.film, matched_movie.score, matched_movie.gross_revenue))
        else:
            print(f&#34;Could not find match for film \&#34;{oscar_info.film}\&#34; ({oscar_info.year_film}).&#34;)

    return awarded_movies


def write_awarded_movies_to_file(awarded_movies: Iterable[AwardedMovie]) -&gt; None:
    &#34;&#34;&#34;
    Creates a CSV file within the local result folder that contains all movies that could be matched. More precisely,
    the CSV file will contain the name, IMDb score, gross revenue in the USA of all films that have been awarded the
    Oscar in the category &#34;Best Picture&#34; and were released between 1986 and 2016 (both inclusively).

    **awarded_movies:** the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)&lt;br/&gt;

    **return type:** `None`
    &#34;&#34;&#34;
    with open(awarded_movies_result_file, &#34;w&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as csv_file:
        csv_writer = csv.writer(csv_file, delimiter=&#34;,&#34;, quotechar=&#34;\&#34;&#34;, quoting=csv.QUOTE_MINIMAL)
        csv_writer.writerow([&#34;year&#34;, &#34;movie&#34;, &#34;score&#34;, &#34;gross_revenue&#34;])  # header row
        csv_rows = map(lambda movie: movie.serialize(), awarded_movies)
        csv_writer.writerows(csv_rows)


def visualize_awarded_movies(awarded_movies: Iterable[AwardedMovie]) -&gt; None:
    &#34;&#34;&#34;
    Creates a PNG image within the local result folder that represents a visualization of the output of the data processing.
    It is a plot that juxtaposes the gross revenue of all movies that won the Best Picture Oscar and were released between 1986 and 2016, along
    with their respective IMDb user score.

    **awarded_movies:** the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)&lt;br/&gt;

    **return type:** `None`
    &#34;&#34;&#34;

    def label_in_millions(value, _):
        return f&#39;{value * 1e-6:1.0f} M&#39;

    def next_hundred_million(value):
        return math.ceil(value / 100_000_000) * 100_000_000

    # prepare data: year and film on the x-axis, gross revenue and IMDb user score on the y-axes
    x_labels = np.array(list(map(lambda movie: f&#34;{movie.year}: {movie.movie}&#34;, awarded_movies)))
    y_values_revenue = np.array(list(map(lambda movie: movie.gross_revenue, awarded_movies)))
    y_values_score = np.array(list(map(lambda movie: movie.score, awarded_movies)))

    # general plot setup
    fig, ax1 = plt.subplots(figsize=(10, 10))
    plt.xticks(rotation=270)
    plt.suptitle(&#34;Gross Revenue vs. IMDb Score of Oscar Best Picture Winners\n(1986-2016)&#34;, fontsize=16, weight=&#34;bold&#34;)
    millions_formatter = ticker.FuncFormatter(label_in_millions)

    # x-axis: display all years and movies
    ax1.set_xlabel(&#39;Oscar Years and Films&#39;, weight=&#34;bold&#34;, labelpad=5)
    ax1.xaxis.set_major_locator(ticker.FixedLocator(x_labels))
    ax1.set_xticks(np.arange(len(x_labels)))
    ax1.set_xticklabels(x_labels)

    # first y-axis: display gross revenue in millions
    ax1.set_ylabel(&#39;Gross Revenue in the USA\n(in Millions)&#39;, weight=&#34;bold&#34;, labelpad=10)
    ax1.set_ylim([0, next_hundred_million(max(y_values_revenue))])  # so that the highest y-value is not &#34;glued&#34; to the top of the diagram
    ax1.yaxis.set_major_formatter(millions_formatter)  # so that numbers representing axis labels are not too big
    ax1.plot(x_labels, y_values_revenue, color=&#39;tab:green&#39;, marker=&#34;.&#34;)

    # second y-axis: display IMDb user score
    ax2 = ax1.twinx()  # the second y-axis should share the x-axis with the first y-axis
    ax2.set_ylabel(&#39;IMDb User Score&#39;, weight=&#34;bold&#34;, labelpad=7)
    ax2.set_ylim([0, 10])
    ax2.yaxis.set_major_locator(ticker.FixedLocator(np.arange(0, 11)))  # display all numbers between 0 and 10
    ax2.plot(x_labels, y_values_score, color=&#39;tab:blue&#39;, marker=&#34;.&#34;)

    fig.tight_layout()
    fig.savefig(awarded_movies_visualization_file)


def main() -&gt; None:
    &#34;&#34;&#34;
    Bootstrapper method of the script. Executes the methods necessary to conduct the experiment in the correct order.

    **return type:** `None`
    &#34;&#34;&#34;
    print(f&#34;Ensuring result directory \&#34;{result_folder}\&#34; exists...&#34;, end=&#34;&#34;)
    Path(result_folder).mkdir(parents=True, exist_ok=True)
    print(&#34;Done.&#34;)

    oscar_data: Collection[OscarInfo] = read_oscar_data()
    print(f&#34;Filtered {len(oscar_data)} oscar information entries from \&#34;{oscars_data_file}\&#34;.&#34;)

    movie_data: Collection[Movie] = read_movie_data()
    print(f&#34;Read {len(movie_data)} movie information entries from \&#34;{movie_data_file}\&#34;.&#34;)

    matched_movies: Collection[AwardedMovie] = match_awarded_movies(oscar_data, movie_data)
    print(f&#34;Matched {len(matched_movies)} movies with awards.&#34;)

    write_awarded_movies_to_file(matched_movies)
    print(f&#34;Wrote result of data processing to file \&#34;{awarded_movies_result_file}\&#34;.&#34;)

    visualize_awarded_movies(matched_movies)
    print(f&#34;Saved plot of processed data to file \&#34;{awarded_movies_visualization_file}\&#34;.&#34;)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.main.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Bootstrapper method of the script. Executes the methods necessary to conduct the experiment in the correct order.</p>
<p><strong>return type:</strong> <code>None</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main() -&gt; None:
    &#34;&#34;&#34;
    Bootstrapper method of the script. Executes the methods necessary to conduct the experiment in the correct order.

    **return type:** `None`
    &#34;&#34;&#34;
    print(f&#34;Ensuring result directory \&#34;{result_folder}\&#34; exists...&#34;, end=&#34;&#34;)
    Path(result_folder).mkdir(parents=True, exist_ok=True)
    print(&#34;Done.&#34;)

    oscar_data: Collection[OscarInfo] = read_oscar_data()
    print(f&#34;Filtered {len(oscar_data)} oscar information entries from \&#34;{oscars_data_file}\&#34;.&#34;)

    movie_data: Collection[Movie] = read_movie_data()
    print(f&#34;Read {len(movie_data)} movie information entries from \&#34;{movie_data_file}\&#34;.&#34;)

    matched_movies: Collection[AwardedMovie] = match_awarded_movies(oscar_data, movie_data)
    print(f&#34;Matched {len(matched_movies)} movies with awards.&#34;)

    write_awarded_movies_to_file(matched_movies)
    print(f&#34;Wrote result of data processing to file \&#34;{awarded_movies_result_file}\&#34;.&#34;)

    visualize_awarded_movies(matched_movies)
    print(f&#34;Saved plot of processed data to file \&#34;{awarded_movies_visualization_file}\&#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="src.main.match_awarded_movies"><code class="name flex">
<span>def <span class="ident">match_awarded_movies</span></span>(<span>oscar_infos: Iterable[oscar_info.OscarInfo], movies: Iterable[movie.Movie]) ‑> Collection[awarded_movie.AwardedMovie]</span>
</code></dt>
<dd>
<div class="desc"><p>Matches the information gathered from the Oscar dataset with the one gathered from the IMDb movie dataset. Two entries are
defined to be "matching" if the title and year of the film described are equal in both datasets - i. e. film identity is
defined by the name and finalization/release year.</p>
<p><strong>oscar_infos:</strong> relevant oscar award information to be taken into consideration for the matching<br/>
<strong>movies:</strong> movie data with IMDb information (gross revenue, user score) to be matched with the oscar infos<br/></p>
<p><strong>returns:</strong> Returns a collection of <code>AwardedMovie</code> model instances that represents the processed data gathered by means of the matching.<br/></p>
<p><strong>return type:</strong> <code>Collection[AwardedMovie]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_awarded_movies(oscar_infos: Iterable[OscarInfo], movies: Iterable[Movie]) -&gt; Collection[AwardedMovie]:
    &#34;&#34;&#34;
    Matches the information gathered from the Oscar dataset with the one gathered from the IMDb movie dataset. Two entries are
    defined to be &#34;matching&#34; if the title and year of the film described are equal in both datasets - i. e. film identity is
    defined by the name and finalization/release year.

    **oscar_infos:** relevant oscar award information to be taken into consideration for the matching&lt;br/&gt;
    **movies:** movie data with IMDb information (gross revenue, user score) to be matched with the oscar infos&lt;br/&gt;

    **returns:** Returns a collection of `AwardedMovie` model instances that represents the processed data gathered by means of the matching.&lt;br/&gt;

    **return type:** `Collection[AwardedMovie]`
    &#34;&#34;&#34;
    awarded_movies: List[AwardedMovie] = []

    for oscar_info in oscar_infos:
        def is_match(movie: Movie):
            # we consider a movie equal if the name and year are equal
            return (oscar_info.film.lower() == movie.name.lower()) and (oscar_info.year_film in [movie.year, movie.released.year])

        matched_movie: Movie = next(filter(is_match, movies), None)
        if matched_movie is not None:
            awarded_movies.append(AwardedMovie(oscar_info.year_film, oscar_info.film, matched_movie.score, matched_movie.gross_revenue))
        else:
            print(f&#34;Could not find match for film \&#34;{oscar_info.film}\&#34; ({oscar_info.year_film}).&#34;)

    return awarded_movies</code></pre>
</details>
</dd>
<dt id="src.main.read_csv"><code class="name flex">
<span>def <span class="ident">read_csv</span></span>(<span>file_path: str, expected_headers: Iterable[str], target_type: Type[~_T], predicate: Callable[[~_T], bool], encoding='utf-8', delimiter=',') ‑> Collection[~_T]</span>
</code></dt>
<dd>
<div class="desc"><p>Generic function to deserialize a CSV file into a collection of instances of a specifiable model class. The model class
has to provide a constructor that accepts string parameters representing the columns of a row in the CSV file, in the order defined by the file.</p>
<p><strong>file_path:</strong> the file path to the CSV file to be read<br/>
<strong>expected_headers:</strong> The headers the CSV file is expected to exhibit. If diverging headers are encountered,
an exception with information about the headers that were found in the file is thrown.<br/>
<strong>target_type:</strong> The type (i. e. class) into which CSV entries are deserialized. The class is expected to provide a constructor
that takes the columns' values as string arguments and constructs an instance from them. If such a constructor is not available, a
runtime error will ensue. If the constructor invocation itself fails - e. g. due to a string -&gt; int parsing error - a warning is
printed to stdout and the corresponding row is skipped, i. e. execution continues normally.<br/>
<strong>predicate:</strong> A row entry read from the CSV is added to the return value only if the predicate, invoked with the deserialized
model instance as argument, evaluates to true.<br/>
<strong>encoding:</strong> The encoding to be used when reading the file.<br/>
<strong>delimiter:</strong> a one-character string to be used as the column separator<br/></p>
<p><strong>returns:</strong> Returns a collection of instances of the generic type parameter that were successfully deserialized from the specified
CSV file and also satisfied the given predicate.<br/></p>
<p><strong>return type:</strong> <code>Collection[_T]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv(file_path: str, expected_headers: Iterable[str], target_type: Type[_T], predicate: Callable[[_T], bool],
             encoding=&#34;utf-8&#34;, delimiter=&#34;,&#34;) -&gt; Collection[_T]:
    &#34;&#34;&#34;
    Generic function to deserialize a CSV file into a collection of instances of a specifiable model class. The model class
    has to provide a constructor that accepts string parameters representing the columns of a row in the CSV file, in the order defined by the file.

    **file_path:** the file path to the CSV file to be read&lt;br/&gt;
    **expected_headers:** The headers the CSV file is expected to exhibit. If diverging headers are encountered,
     an exception with information about the headers that were found in the file is thrown.&lt;br/&gt;
    **target_type:** The type (i. e. class) into which CSV entries are deserialized. The class is expected to provide a constructor
     that takes the columns&#39; values as string arguments and constructs an instance from them. If such a constructor is not available, a
     runtime error will ensue. If the constructor invocation itself fails - e. g. due to a string -&gt; int parsing error - a warning is
     printed to stdout and the corresponding row is skipped, i. e. execution continues normally.&lt;br/&gt;
    **predicate:** A row entry read from the CSV is added to the return value only if the predicate, invoked with the deserialized
     model instance as argument, evaluates to true.&lt;br/&gt;
    **encoding:** The encoding to be used when reading the file.&lt;br/&gt;
    **delimiter:** a one-character string to be used as the column separator&lt;br/&gt;

    **returns:** Returns a collection of instances of the generic type parameter that were successfully deserialized from the specified
     CSV file and also satisfied the given predicate.&lt;br/&gt;

    **return type:** `Collection[_T]`
    &#34;&#34;&#34;
    try:
        with open(file_path, encoding=encoding) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=delimiter)
            return_value: List[_T] = []

            headers = next(csv_reader)
            if headers != expected_headers:
                raise Exception(f&#34;Unexpected CSV headers. Check if &#39;{file_path}&#39; is the correct file.\n&#34;
                                f&#34;Expected: {expected_headers}\nActual:   {headers}&#34;)

            for row in csv_reader:
                try:
                    # as per the precondition formulated in the documentation, the model classes provide constructors that
                    # take the string value of each column as parameters and try to parse them into the correct data types
                    new_entry: _T = target_type(*row)
                except Exception as ex:
                    print(f&#34;Skipping entry {row} because it cannot be deserialized.\n  Error: {ex}&#34;)

                if predicate(new_entry):
                    return_value.append(new_entry)

            return return_value
    except FileNotFoundError as ex:
        print(f&#34;Could not read CSV file at \&#34;{file_path}\&#34;.\n  Error: {ex}&#34;)
        print(f&#34;Aborting because the experiment cannot be conducted if at least one data set cannot be read.&#34;)
        exit(1)</code></pre>
</details>
</dd>
<dt id="src.main.read_movie_data"><code class="name flex">
<span>def <span class="ident">read_movie_data</span></span>(<span>) ‑> Collection[movie.Movie]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the CSV dataset with IMDb information about movies from 1986 to 2016 and deserializes it into <code>Movie</code> model instances.</p>
<p><strong>returns:</strong> Returns a collection of <code>Movie</code> instances that represents the raw information of the IMDb movie dataset.<br/></p>
<p><strong>return type:</strong> <code>Collection[Movie]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_movie_data() -&gt; Collection[Movie]:
    &#34;&#34;&#34;
    Parses the CSV dataset with IMDb information about movies from 1986 to 2016 and deserializes it into `Movie` model instances.

    **returns:** Returns a collection of `Movie` instances that represents the raw information of the IMDb movie dataset.&lt;br/&gt;

    **return type:** `Collection[Movie]`
    &#34;&#34;&#34;

    def is_relevant(_: Movie) -&gt; bool:
        # all movie entries are relevant
        return True

    expected_headers = [&#34;budget&#34;, &#34;company&#34;, &#34;country&#34;, &#34;director&#34;, &#34;genre&#34;, &#34;gross&#34;, &#34;name&#34;, &#34;rating&#34;,
                        &#34;released&#34;, &#34;runtime&#34;, &#34;score&#34;, &#34;star&#34;, &#34;votes&#34;, &#34;writer&#34;, &#34;year&#34;]

    return read_csv(movie_data_file, expected_headers, Movie, is_relevant)</code></pre>
</details>
</dd>
<dt id="src.main.read_oscar_data"><code class="name flex">
<span>def <span class="ident">read_oscar_data</span></span>(<span>) ‑> Collection[oscar_info.OscarInfo]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the CSV dataset with Oscar nomination and winners from 1928 until 2020, applies a filter by year and category and deserializes the
entries satisfying the criteria into <code>OscarInfo</code> model instances.</p>
<p><strong>returns:</strong> Returns a collection of <code>OscarInfo</code> instances that represents information from the Oscar award dataset describing Oscar winners
released 1986 and 2016 (both inclusively) from the category "Best Picture".<br/></p>
<p><strong>return type:</strong> <code>Collection[OscarInfo]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_oscar_data() -&gt; Collection[OscarInfo]:
    &#34;&#34;&#34;
    Parses the CSV dataset with Oscar nomination and winners from 1928 until 2020, applies a filter by year and category and deserializes the
    entries satisfying the criteria into `OscarInfo` model instances.

    **returns:** Returns a collection of `OscarInfo` instances that represents information from the Oscar award dataset describing Oscar winners
     released 1986 and 2016 (both inclusively) from the category &#34;Best Picture&#34;.&lt;br/&gt;

    **return type:** `Collection[OscarInfo]`
    &#34;&#34;&#34;

    def is_relevant(oscar_info: OscarInfo) -&gt; bool:
        # we are only interested in oscar infos that represent the winners of a &#34;Best Picture&#34; award released between 1986 and 2016 (both inclusively)
        return (1986 &lt;= oscar_info.year_film &lt;= 2016) and (oscar_info.category.lower() == &#34;best picture&#34;) and (oscar_info.winner is True)

    expected_headers = [&#34;year_film&#34;, &#34;year_ceremony&#34;, &#34;ceremony&#34;, &#34;category&#34;, &#34;name&#34;, &#34;film&#34;, &#34;winner&#34;]

    return read_csv(oscars_data_file, expected_headers, OscarInfo, is_relevant)</code></pre>
</details>
</dd>
<dt id="src.main.visualize_awarded_movies"><code class="name flex">
<span>def <span class="ident">visualize_awarded_movies</span></span>(<span>awarded_movies: Iterable[awarded_movie.AwardedMovie]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a PNG image within the local result folder that represents a visualization of the output of the data processing.
It is a plot that juxtaposes the gross revenue of all movies that won the Best Picture Oscar and were released between 1986 and 2016, along
with their respective IMDb user score.</p>
<p><strong>awarded_movies:</strong> the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)<br/></p>
<p><strong>return type:</strong> <code>None</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_awarded_movies(awarded_movies: Iterable[AwardedMovie]) -&gt; None:
    &#34;&#34;&#34;
    Creates a PNG image within the local result folder that represents a visualization of the output of the data processing.
    It is a plot that juxtaposes the gross revenue of all movies that won the Best Picture Oscar and were released between 1986 and 2016, along
    with their respective IMDb user score.

    **awarded_movies:** the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)&lt;br/&gt;

    **return type:** `None`
    &#34;&#34;&#34;

    def label_in_millions(value, _):
        return f&#39;{value * 1e-6:1.0f} M&#39;

    def next_hundred_million(value):
        return math.ceil(value / 100_000_000) * 100_000_000

    # prepare data: year and film on the x-axis, gross revenue and IMDb user score on the y-axes
    x_labels = np.array(list(map(lambda movie: f&#34;{movie.year}: {movie.movie}&#34;, awarded_movies)))
    y_values_revenue = np.array(list(map(lambda movie: movie.gross_revenue, awarded_movies)))
    y_values_score = np.array(list(map(lambda movie: movie.score, awarded_movies)))

    # general plot setup
    fig, ax1 = plt.subplots(figsize=(10, 10))
    plt.xticks(rotation=270)
    plt.suptitle(&#34;Gross Revenue vs. IMDb Score of Oscar Best Picture Winners\n(1986-2016)&#34;, fontsize=16, weight=&#34;bold&#34;)
    millions_formatter = ticker.FuncFormatter(label_in_millions)

    # x-axis: display all years and movies
    ax1.set_xlabel(&#39;Oscar Years and Films&#39;, weight=&#34;bold&#34;, labelpad=5)
    ax1.xaxis.set_major_locator(ticker.FixedLocator(x_labels))
    ax1.set_xticks(np.arange(len(x_labels)))
    ax1.set_xticklabels(x_labels)

    # first y-axis: display gross revenue in millions
    ax1.set_ylabel(&#39;Gross Revenue in the USA\n(in Millions)&#39;, weight=&#34;bold&#34;, labelpad=10)
    ax1.set_ylim([0, next_hundred_million(max(y_values_revenue))])  # so that the highest y-value is not &#34;glued&#34; to the top of the diagram
    ax1.yaxis.set_major_formatter(millions_formatter)  # so that numbers representing axis labels are not too big
    ax1.plot(x_labels, y_values_revenue, color=&#39;tab:green&#39;, marker=&#34;.&#34;)

    # second y-axis: display IMDb user score
    ax2 = ax1.twinx()  # the second y-axis should share the x-axis with the first y-axis
    ax2.set_ylabel(&#39;IMDb User Score&#39;, weight=&#34;bold&#34;, labelpad=7)
    ax2.set_ylim([0, 10])
    ax2.yaxis.set_major_locator(ticker.FixedLocator(np.arange(0, 11)))  # display all numbers between 0 and 10
    ax2.plot(x_labels, y_values_score, color=&#39;tab:blue&#39;, marker=&#34;.&#34;)

    fig.tight_layout()
    fig.savefig(awarded_movies_visualization_file)</code></pre>
</details>
</dd>
<dt id="src.main.write_awarded_movies_to_file"><code class="name flex">
<span>def <span class="ident">write_awarded_movies_to_file</span></span>(<span>awarded_movies: Iterable[awarded_movie.AwardedMovie]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a CSV file within the local result folder that contains all movies that could be matched. More precisely,
the CSV file will contain the name, IMDb score, gross revenue in the USA of all films that have been awarded the
Oscar in the category "Best Picture" and were released between 1986 and 2016 (both inclusively).</p>
<p><strong>awarded_movies:</strong> the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)<br/></p>
<p><strong>return type:</strong> <code>None</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_awarded_movies_to_file(awarded_movies: Iterable[AwardedMovie]) -&gt; None:
    &#34;&#34;&#34;
    Creates a CSV file within the local result folder that contains all movies that could be matched. More precisely,
    the CSV file will contain the name, IMDb score, gross revenue in the USA of all films that have been awarded the
    Oscar in the category &#34;Best Picture&#34; and were released between 1986 and 2016 (both inclusively).

    **awarded_movies:** the movies that were matched successfully between the two datasets (Oscar awards, IMDb data)&lt;br/&gt;

    **return type:** `None`
    &#34;&#34;&#34;
    with open(awarded_movies_result_file, &#34;w&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as csv_file:
        csv_writer = csv.writer(csv_file, delimiter=&#34;,&#34;, quotechar=&#34;\&#34;&#34;, quoting=csv.QUOTE_MINIMAL)
        csv_writer.writerow([&#34;year&#34;, &#34;movie&#34;, &#34;score&#34;, &#34;gross_revenue&#34;])  # header row
        csv_rows = map(lambda movie: movie.serialize(), awarded_movies)
        csv_writer.writerows(csv_rows)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.main.main" href="#src.main.main">main</a></code></li>
<li><code><a title="src.main.match_awarded_movies" href="#src.main.match_awarded_movies">match_awarded_movies</a></code></li>
<li><code><a title="src.main.read_csv" href="#src.main.read_csv">read_csv</a></code></li>
<li><code><a title="src.main.read_movie_data" href="#src.main.read_movie_data">read_movie_data</a></code></li>
<li><code><a title="src.main.read_oscar_data" href="#src.main.read_oscar_data">read_oscar_data</a></code></li>
<li><code><a title="src.main.visualize_awarded_movies" href="#src.main.visualize_awarded_movies">visualize_awarded_movies</a></code></li>
<li><code><a title="src.main.write_awarded_movies_to_file" href="#src.main.write_awarded_movies_to_file">write_awarded_movies_to_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>